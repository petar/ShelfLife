<!doctype html>
<!--[if lt IE 7 ]><html lang="en" class="no-js ie6"><![endif]-->
<!--[if (gt IE 6)|!(IE)]><!--><html lang="en" class="no-js"><!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />

    <title>Sociability documentation</title>
    <meta name="description" content="Sociability dcumentation">
    <meta name="author" content="Petar Maymounkov">

    <link href="screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
</head>

<body>
	<div class="content">
		<h2>Architecture</h2>
		<p>Sociability comes in two parts: front-end (client side) and back-end
		(server-side). The backend includes a MongoDB database which is used for
		storting all user and activity data and an HTTP server ("server" for short)
		which services Ajax API requests from the client as well as requests 
		for some static resources like style sheets. Schematically, the paths of
		communication look like this:</p>
		<pre>Front-end (Browser JS) <-- TCP --> Server (Go Language) <-- TCP --> MongoDB</pre>
		
		<p>The basic idea is that the server is in charge of performing, upon request, all social
		functions like <code>Like(user, object)</code> which when called stores the fact
		that <code>user</code> likes <code>object</code> in the persistent database.
		These functions are exposed as AJAX calls.
		</p>

		<p>On the client side, we have a JavaScript library which facilitates the
		interaction with the server and provides some useful out-of-the-box UI components.
		The client side JS has two types of functions. There are low-level functions which
		do nothing more than wrap all AJAX server calls in convenient JS functions. And
		there are higher level functions, which wrap user information in <a
			href="http://documentcloud.github.com/backbone/">backbone.js</a> models and views.</p>

		<p>Every sociability feature, like the User Join/Sign In System e.g., has some respective code
		on the client side and the server side and has a representation in the database.
		We are going to briefly walk through an example which will sketch out all three
		parts of a feature and will demonstrate the general structure of the code. But
		first we cover some preliminaries of Sociability's internal design.</p>

		<h3>Sociability code structure</h3>
		There are four subdirectories inside <code>src</code>
<pre>
cmd          Source code for the server exetuable
pkg          Sociability-specific Go Libraries
static       Static files (like stylesheets) served by the server
thirdparty   Third-party Go Language libraries
</pre>
		<p><code>static</code> contains various resources, essentially text files, that are
		served by the server and used by the client-side library. These include the style
		sheets, the client-side JavaScript itself, as well as a file called 
		<code>ui.x-jquery-tmpl</code> which contains the HTML templates for the UI
		components.
		</p>

		<p><code>thirdparty</code> contains copies of five external Go Language libraries
		which are used by Sociability: <a href="http://labix.org/gobson">gobson</a> is a library for reading and 
		writing data in the network format of MongoDB; <a href="http://labix.org/mgo">mgo</a> is a driver for
		the MongoDB for the Go Language; <a href="https://github.com/dchest/authcookie">authcookie</a> is a library for reading
		and writing "authenticated cookies", which are used in the user authentication
		system of Sociability. All three libraries have extensive documentation on their
		respective sites; <a href="https://github.com/petar/GoHTTP">GoHTTP</a> is the HTTP server infrastructure used by
		Sociability; and <a href="https://github.com/petar/GoGauge">GoGauge</a> is a small instrumentation library used
		internally by GoHTTP.</p>

		<p><code>pkg</code> contains two Go Language libraries that implement all
		Sociability functionality. The first one, <code>db</code>, takes care of
		interactions with the database. The second one, <code>sociability</code> takes care
		of implementing the AJAX server calls.</p>

		<p><code>cmd</code> contains the source code for the sociability server. This is
		really just wrapper code that reads configuration parameters from the command line
		that reads configuration parameters from the command line, instantiates a web server
		that responds to AJAX calls using the <code>sociability</code> Go library and runs
		the server.</p>

		<h3>Database schema</h3>

		<p>For starters, all source files dealing with access to the database are found in the directory
		<code>src/pkg/db</code>. The main database interface class is in <code>db.go</code>
		which simply takes care of connecting to MongoDB, using the <a
			href="http://labix.org/mgo">mgo</a>
		Go driver.
		</p>

		<p>What is more interesting is that Sociability uses MongoDB through
		an abstraction layer that implements a "graph database". In this database,
		there are two storeable objects: vertices and edges. Additionally, an arbitrary
		document can be attached to both of these objects.</p>

		<p>In more detail, every vertex is identified by an abstract (user-defined) <em>type</em> and a 
		<em>unique ID</em>. The available vertex types are declared before
		database usage ensues (via appropriate functional calls). The vertex's unique ID is
		allocated at runtime when the vertex is inserted for the first time.
		</p>

		<p>Every edge has an edge type, a unique ID and two vertices as endpoints. The edge
		types, similarly to vertex types, are declared before database usage begins. The
		edge types are user-defined, abstract labels, which additionally specify what are
		the vertex types of the <em>from</em> and <em>to</em> endpoints of an edge.
		Like vertices, an arbitrary MongoDB document can be attached to every edge.</p>

		<p>The file <code>src/pkg/db/kpartite.go</code> holds the implementation of the
		graph database abstraction on top of MongoDB. This file contains a long list of
		useful functions, like "add vertex", "add edge", "list neighbors", 
		"delete vertex and its incident edges", etc.
		</p>

		<h3>A walk through the user system</h3>
		<p>We'll take a quick look at how the user join and sign in system works.
	       	This should give a good example of the code structure of a typical social
		functionality or feature.</p>

		<p>Virtually every feature is comprised of code in three locations: database-related
		code goes in <code>pkg/db</code>, API functions' implementation goes in 
		<code>pkg/sociability</code> and client-side code goes in
		<code>static/js/ss.js</code>. For the user system specifically, the database
		part is in the file <code>pkg/db/user.go</code>, the API part is in
		<code>pkg/sociability/login.go</code> and the client-side code is represented
		by the namespace <code>ss.login</code> inside <code>static/js/ss.js</code>.

		<h4>The database part</h4>
		<p>Note that it is recommended that you familiarize yourself with the <a
			href="http://labix.org/mgo">mgo</a> MongoDB driver documentation before you start
		looking into the Sociability database-related code.</p>

		<p>The database part of every feature follows a similar structure. Let's take a look
		at <code>pkg/db/user.go</code>.</p>

		<p>First you will see the data structure 
		<code>UserDoc</code> which defines the MongoDB document, containing user
		information, that will be attached to every vertex that corresponds to a user.
		</p>

		<p>The <code>initUser</code> function is called in the beginning, before the server
		starts serving requests. This function prepares the graph database for the
		user-specific database operation. All it does is to declare a new vertex type called 
		<code>user</code> and request a MongoDB index on the commonly queried fields 
		<code>email</code> and <code>login</code>. All Sociability features will have a
		similar database initialization function that generally do two things:
		declare vertex and edge types and install MongoDB indicies (or uniqueness rules).
		</p>

		<p>The rest of the functions in <code>pkg/db/user.go</code> are well-documented and
		pretty self-explanatory. Take a look at <code>AddUser</code>, which adds a new
		user to the database, and <code>FindUserByEmail</code>, which looks up a user record
		by email.</p>

		<h4>The API part</h4>
		<p>Sociability uses GoHTTP's infrastructure for building HTTP (AJAX) APIs. The way
		this works is quite simple. The GoHTTP server takes a Go struct and its methods and
		exports all "public" methods (those whose name starts with an uppercase letter) as
		AJAX API calls. The methods that are exported need to have a specific argument
		signature. For example,
<pre>
SignInLogin(args *rpc.Args, r *rpc.Ret) (err os.Error)
</pre>
		<p>The first argument <code>args</code> encapsulates all input information provided
		to the AJAX call. This includes URL arguments, HTTP body arguments (for POST
		requests) and cookies in the HTTP request. All of these can be accessed by the
		methods of the <code>rpc.Args</code>, which is found in the 
		<code>github.com/petar/GoHTTP/server/rpc</code> package.</p>

		<p>The API class for Sociability is defined in
		<code>src/pkg/sociability/api.go</code>, but most of its methods can be found in
		other source files that are feature specific. This why find all API calls of the
		user system in <code>src/pkg/sociability/login.go</code>.</p>

		<p>The method <code>SignInLogin</code> (found in <code>login.go</code>), for example,
		is a great demonstration of what a typical API call implementation looks like. This
		method is also well-documented in the source file.</p>

		<p>The method starts with calls to <code>args.QueryString</code> which extract the
		various arguments passed as part of the HTTP request URL. It then invokes the
		method <code>FindUserByLogin</code>, which is implemented in the database part of 
		the user system, which fetches the user structure for the request username.
		The method then concludes by setting some user authentication cookies, using
		a call to <code>r.AddSetCookie</code>, and adding some result data in the JSON body
		of the HTTP response via a call to <code>r.SetInt</code>.

		<h4>The client-side part</h4>
		<p>The client-side is entirely contained in the file
		<code>src/static/js/ss.js</code>. This is effectively a JavaScript library to be
		included in Sociability-enabled web-pages. The library declares a few different
		namespaces like <code>ss.util</code>, <code>ss.login</code>, <code>ss.social</code>,
		etc., where each namespace contains functions or objects of related nature.</p>

		<p>Two of the namespaces, namely <code>ss.login</code> and <code>ss.social</code>,
		provide functions that correspond to every HTTP API call (supported by the server) 
		by wrapping the details of AJAX calling using jQuery. In a sense, these namespaces
		provide the lowest-level access to Sociability on your web-page.</p>

		<p>The function-oriented interface to Sociability is generally not convenient for
		web app developers. Consider for example the message thread of a social object. The
		thread changes over time and if a developer were to keep a fresh view of the thread
		on screen, they would have to perform polling using the respective AJAX calls to the
		sociability messaging system. This is awkward.</p>

		<p>In order to avoid the awkwardness of polling semantics, Sociability builds a
		higher-level client-side interface, based on <a
			href="http://documentcloud.github.com/backbone/">backbone.js</a> models.
		It is
	</div>
</body>
</html>
